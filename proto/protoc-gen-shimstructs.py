#!/usr/bin/env python3
"""protoc plugin that generates lightweight C++ structs and Emscripten bindings.

This tool reads protobuf descriptors and emits header/source pairs that contain
plain structs mirroring the protobuf schema along with embind registrations so
that the data structures are available to JavaScript when building with
Emscripten.
"""

from __future__ import annotations

from csv import writer
import os
import re
import sys
from typing import Any, Dict, Iterable, List, Optional, Tuple

from google.protobuf import descriptor_pool
from google.protobuf.compiler import plugin_pb2  # type: ignore[attr-defined]
from google.protobuf.descriptor import Descriptor, EnumDescriptor, FieldDescriptor, FileDescriptor, OneofDescriptor


NAMESPACE = "valhalla"
HEADER_COMMENT = "// Generated by protoc-gen-shimstructs. DO NOT EDIT.\n"
INDENT = "  "


class CodeWriter:
    def __init__(self) -> None:
        self._lines: List[str] = []
        self._indent = 0

    def write(self, text: str = "") -> None:
        if text:
            self._lines.append(f"{INDENT * self._indent}{text}")
        else:
            self._lines.append("")

    def indent(self) -> None:
        self._indent += 1

    def dedent(self) -> None:
        if self._indent == 0:
            raise RuntimeError("dedent() called on zero indentation")
        self._indent -= 1

    def render(self) -> str:
        return "\n".join(self._lines) + "\n"


class FieldMetadata:
    def __init__(
        self,
        *,
        field: FieldDescriptor,
        type_string: str,
        initializer: str,
        category: str,
        storage_name: str,
        element_type: Optional[str] = None,
        key_type: Optional[str] = None,
        value_type: Optional[str] = None,
        presence_var: Optional[str] = None,
        key_category: Optional[str] = None,
        value_category: Optional[str] = None,
        value_cpp_type: Optional[int] = None,
    ) -> None:
        self.field = field
        self.type_string = type_string
        self.initializer = initializer
        self.category = category
        self.storage_name = storage_name
        self.element_type = element_type
        self.key_type = key_type
        self.value_type = value_type
        self.presence_var = presence_var
        self.key_category = key_category
        self.value_category = value_category
        self.value_cpp_type = value_cpp_type


class MessageBinding:
    def __init__(self, descriptor: Descriptor, qualified_name: str, binding_name: str) -> None:
        self.descriptor = descriptor
        self.qualified_name = qualified_name
        self.binding_name = binding_name
        # (public_name, member_name)
        self.fields: List[Tuple[str, str]] = []
        self.field_metadata: List[FieldMetadata] = []
        self.presence_var_by_oneof: Dict[str, str] = {}


class FileContext:
    def __init__(self) -> None:
        self.message_bindings: List[MessageBinding] = []
        self.enum_bindings: List[Tuple[EnumDescriptor, str]] = []
        self.vector_types: Dict[str, str] = {}  # element_type -> registration name
        self.map_types: Dict[Tuple[str, str], str] = {}  # (key_type, value_type) -> registration name


class Generator:
    def __init__(self, request: plugin_pb2.CodeGeneratorRequest) -> None:
        self._request = request
        self._pool = descriptor_pool.DescriptorPool()
        self.already_reg_set: set[str] = set()
        for proto in request.proto_file:
            self._pool.Add(proto)
        self._files: Dict[str, FileDescriptor] = {}
        # `FindFileByName` returns FileDescriptor.
        for proto in request.proto_file:
            file_descriptor = self._pool.FindFileByName(proto.name)
            self._files[proto.name] = file_descriptor

    def generate(self) -> plugin_pb2.CodeGeneratorResponse:
        response_cls = getattr(plugin_pb2, "CodeGeneratorResponse")
        response = response_cls()
        for file_name in self._request.file_to_generate:
            file_descriptor = self._pool.FindFileByName(file_name)
            context = FileContext()
            header_content = self._generate_header(file_descriptor, context)
            source_content = self._generate_source(file_descriptor, context)
            base = os.path.splitext(file_descriptor.name)[0]
            header_path = f"{base}.pb.h"
            source_path = f"{base}.pb.cc"
            header_file = response.file.add()
            header_file.name = header_path
            header_file.content = header_content
            source_file = response.file.add()
            source_file.name = source_path
            source_file.content = source_content
        return response

    def _generate_header(self, file_descriptor, context: FileContext) -> str:
        writer = CodeWriter()
        writer.write(HEADER_COMMENT.strip())
        guard = self._make_include_guard(file_descriptor.name)
        writer.write(f"#ifndef {guard}")
        writer.write(f"#define {guard}")
        writer.write()
        writer.write("#include <cstddef>")
        writer.write("#include <cstdint>")
        writer.write("#include <cstring>")
        writer.write("#include <limits>")
        writer.write("#include <map>")
        writer.write("#include <string>")
        writer.write("#include <utility>")
        writer.write("#include <vector>")
        writer.write()
        writer.write('#include "protobuf_shims.h"')
        writer.write()
        for dependency in file_descriptor.dependencies:
            if dependency.name.startswith("google/"):
                continue
            include_path = os.path.splitext(dependency.name)[0] + ".pb.h"
            writer.write(f'#include "{include_path}"')
        if file_descriptor.dependencies:
            writer.write()
        writer.write(f"namespace {NAMESPACE} {{")
        writer.write()
        for enum_descriptor in self._file_all_enum_descriptors(file_descriptor):
            self._emit_enum_definition(enum_descriptor, writer, context)
        for message_descriptor in self._file_message_descriptors(file_descriptor):
            self._emit_message(message_descriptor, writer, context)
        writer.write(f"}} // namespace {NAMESPACE}")
        writer.write()

        writer.write("namespace std {")
        for enum_descriptor, _ in context.enum_bindings:
            qualified = self._enum_type_name(enum_descriptor)
            writer.write(f"inline std::string to_string({NAMESPACE}::{qualified} value) {{")
            writer.indent()
            writer.write("switch (value) {")
            writer.indent()
            for value in enum_descriptor.values:
                writer.write(f'case {NAMESPACE}::{qualified}::{value.name}: return "{value.name}";')
            writer.write("default: return std::to_string(static_cast<int>(value));")
            writer.dedent()
            writer.write("}")
            writer.dedent()
            writer.write("}")
            writer.write()
        writer.write("}  // namespace std")

        writer.write(f"#endif  // {guard}")
        return writer.render()


    def _generate_source(self, file_descriptor, context: FileContext) -> str:
        writer = CodeWriter()
        writer.write(HEADER_COMMENT.strip())
        include_path = os.path.splitext(file_descriptor.name)[0] + ".pb.h"
        writer.write(f'#include "{include_path}"')
        writer.write()
        writer.write("#include <protozero/pbf_reader.hpp>")
        writer.write("#include <protozero/pbf_writer.hpp>")
        writer.write()
        writer.write(f"namespace {NAMESPACE} {{")
        for binding in context.message_bindings:
            self._emit_serialization_methods(binding, binding.qualified_name, writer)
        writer.write(f"}} // namespace {NAMESPACE}")
        writer.write()
        return writer.render()

    def _emit_enum_definition(self, enum_descriptor: EnumDescriptor, writer: CodeWriter, context: FileContext) -> None:
        context.enum_bindings.append((enum_descriptor, self._binding_name(enum_descriptor.full_name)))
        writer.write(f"enum class {self._enum_type_name(enum_descriptor)} {{")
        writer.indent()
        for value in enum_descriptor.values:
            writer.write(f"{value.name} = {value.number},")
        writer.dedent()
        writer.write("};")
        writer.write()

        for value in enum_descriptor.values:
            writer.write(
                f"inline constexpr {self._enum_type_name(enum_descriptor)} {self._enum_type_name(enum_descriptor)}_{value.name} = {self._enum_type_name(enum_descriptor)}::{value.name};"
            )
        values = sorted(enum_descriptor.values, key=lambda v: v.number)
        if values:
            enum_type = self._enum_type_name(enum_descriptor)
            min_name = values[0].name
            max_name = values[-1].name
            writer.write(
                f"inline constexpr {enum_type} {enum_type}_MIN = {enum_type}::{min_name};"
            )
            writer.write(
                f"inline constexpr {enum_type} {enum_type}_MAX = {enum_type}::{max_name};"
            )
            writer.write(
                f"inline constexpr int {enum_type}_ARRAYSIZE = static_cast<int>({enum_type}::{max_name}) + 1;"
            )
        writer.write()

        enum_type = self._enum_type_name(enum_descriptor)
        writer.write(f"inline bool {enum_type}_IsValid({enum_type} value) {{")
        writer.indent()
        writer.write(f"return value >= ({enum_type}) 0 && value <= {enum_type}_MAX;")
        writer.dedent()
        writer.write("}")
        writer.write()

    def _emit_message(self, message_descriptor: Descriptor, writer: CodeWriter, context: FileContext) -> None:
        if message_descriptor.GetOptions().map_entry:
            return
        qualified_name = self._qualify_message(message_descriptor)
        binding_name = self._binding_name(message_descriptor.full_name)
        binding = MessageBinding(message_descriptor, qualified_name, binding_name)
        context.message_bindings.append(binding)
        
        # Use flattened name for nested messages (e.g., DirectionsLeg_Maneuver instead of nested class)
        class_name = self._get_flattened_message_name(message_descriptor)
        writer.write(f"class {class_name} {{\npublic:")
        writer.indent()
        copy_fields: List[str] = []
        repeated_shims: List[Tuple[str, str, str]] = []
        map_shims: List[Tuple[str, str, str, str]] = []

        for enum_descriptor in message_descriptor.enum_types:
            writer.write(f"using {enum_descriptor.name} = {self._qualify_enum(enum_descriptor)};")
            for value in enum_descriptor.values:
                writer.write(
                    f"inline static constexpr {enum_descriptor.name} {value.name} = {self._qualify_enum(enum_descriptor)}::{value.name};"
                )
            values = sorted(enum_descriptor.values, key=lambda v: v.number)
            if values:
                min_const = f"valhalla::{self._enum_type_name(enum_descriptor)}_MIN"
                max_const = f"valhalla::{self._enum_type_name(enum_descriptor)}_MAX"
                size_const = f"valhalla::{self._enum_type_name(enum_descriptor)}_ARRAYSIZE"
                writer.write(
                    f"inline static constexpr {enum_descriptor.name} {enum_descriptor.name}_MIN = {min_const};"
                )
                writer.write(
                    f"inline static constexpr {enum_descriptor.name} {enum_descriptor.name}_MAX = {max_const};"
                )
                writer.write(
                    f"inline static constexpr int {enum_descriptor.name}_ARRAYSIZE = {size_const};"
                )
        # Add type aliases for nested messages to allow accessing them like Parent::Nested
        for nested in message_descriptor.nested_types:
            if nested.GetOptions().map_entry:
                continue
            nested_flattened_name = self._get_flattened_message_name(nested)
            writer.write(f"using {nested.name} = {NAMESPACE}::{nested_flattened_name};")
        
        for oneof in message_descriptor.oneofs:
            if self._is_presence_oneof(oneof):
                presence_public = f"{oneof.name}_present"
                presence_storage = self._storage_name(presence_public)
                writer.write(f"bool {presence_storage} = false;")
                binding.fields.append((presence_public, presence_storage))
                binding.presence_var_by_oneof[oneof.name] = presence_storage
                copy_fields.append(presence_storage)
        for field in message_descriptor.fields:
            if field.containing_oneof and not self._is_presence_oneof(field.containing_oneof):
                raise NotImplementedError(
                    f"oneof '{field.containing_oneof.name}' in {message_descriptor.full_name} is not supported"
                )
            metadata = self._make_field_metadata(field, context)
            if field.containing_oneof and self._is_presence_oneof(field.containing_oneof):
                metadata.presence_var = binding.presence_var_by_oneof[field.containing_oneof.name]
            
            # For optional fields (including proto3 optional), add a presence variable
            # Check if field has explicit presence (proto3 optional or in a presence oneof)
            if (
                metadata.category == "message"
                and field.label != FieldDescriptor.LABEL_REPEATED
                and metadata.presence_var is None
            ):
                presence_public = f"has_{field.name}_present"
                presence_storage = self._storage_name(presence_public)
                writer.write(f"bool {presence_storage} = false;")
                copy_fields.append(presence_storage)
                metadata.presence_var = presence_storage
            
            # Handle proto3 optional scalar/enum/string fields
            # In proto3, optional fields are placed in a synthetic oneof, but we also check has_presence
            if (
                metadata.presence_var is None
                and field.label != FieldDescriptor.LABEL_REPEATED
                and metadata.category in {"scalar", "bool", "enum", "string"}
                and hasattr(field, 'has_presence') 
                and field.has_presence
            ):
                presence_public = f"has_{field.name}_present"
                presence_storage = self._storage_name(presence_public)
                writer.write(f"bool {presence_storage} = false;")
                copy_fields.append(presence_storage)
                metadata.presence_var = presence_storage

            writer.write(f"{metadata.type_string} {metadata.storage_name}{metadata.initializer};")
            binding.fields.append((field.name, metadata.storage_name))
            binding.field_metadata.append(metadata)
            copy_fields.append(metadata.storage_name)
            if metadata.category == "repeated" and metadata.element_type:
                shim_name = f"{metadata.storage_name}__shim_"
                repeated_shims.append((shim_name, metadata.storage_name, metadata.element_type))
            if metadata.category == "map" and metadata.key_type and metadata.value_type:
                shim_name = f"{metadata.storage_name}__shim_"
                map_shims.append((shim_name, metadata.storage_name, metadata.key_type, metadata.value_type))

        if binding.field_metadata:
            writer.write()
            for field_metadata in binding.field_metadata:
                self._emit_field_accessors(field_metadata, writer)

        class_name = message_descriptor.name
        flattened_name = self._get_flattened_message_name(message_descriptor)

        writer.write(f"inline void Swap({flattened_name}* other) {{")
        writer.indent()
        writer.write("if (this == other) return;")
        for storage_name in copy_fields:
            writer.write(f"std::swap({storage_name}, other->{storage_name});")
        writer.dedent()
        writer.write("}")
        writer.write(f"inline void CopyFrom(const {flattened_name}& other) {{")
        writer.indent()
        writer.write("*this = other;")
        writer.dedent()
        writer.write("}")
        writer.write(f"inline void MoveFrom({flattened_name}&& other) {{")
        writer.indent()
        writer.write("*this = std::move(other);")
        writer.dedent()
        writer.write("}")
        writer.write(f"inline void Clear() {{ *this = {flattened_name}{{}}; }}")
        writer.write()
        writer.write(f"inline static const {flattened_name}& default_instance() {{")
        writer.indent()
        writer.write(f"static const {flattened_name} instance{{}};")
        writer.write("return instance;")
        writer.dedent()
        writer.write("}")
        writer.write()
        writer.write("bool SerializeToProtozero(std::string* buffer) const;")
        writer.write("bool SerializeToArray(void* data, int size) const;")
        writer.write("bool SerializeToString(std::string* output) const;")
        writer.write("bool ParseFromArray(const void* data, int size);")
        writer.write("bool ParseFromString(const std::string& input);")
        writer.dedent()
        writer.write("};")
        writer.write()

    def _emit_serialization_methods(self, binding: MessageBinding, flattened_name: str, writer: CodeWriter) -> None:
        def writer_method(field: FieldDescriptor) -> str:
            mapping = {
                FieldDescriptor.TYPE_DOUBLE: "add_double",
                FieldDescriptor.TYPE_FLOAT: "add_float",
                FieldDescriptor.TYPE_INT64: "add_int64",
                FieldDescriptor.TYPE_UINT64: "add_uint64",
                FieldDescriptor.TYPE_INT32: "add_int32",
                FieldDescriptor.TYPE_FIXED64: "add_fixed64",
                FieldDescriptor.TYPE_FIXED32: "add_fixed32",
                FieldDescriptor.TYPE_BOOL: "add_bool",
                FieldDescriptor.TYPE_UINT32: "add_uint32",
                FieldDescriptor.TYPE_ENUM: "add_enum",
                FieldDescriptor.TYPE_SFIXED32: "add_sfixed32",
                FieldDescriptor.TYPE_SFIXED64: "add_sfixed64",
                FieldDescriptor.TYPE_SINT32: "add_sint32",
                FieldDescriptor.TYPE_SINT64: "add_sint64",
                FieldDescriptor.TYPE_BYTES: "add_bytes",
                FieldDescriptor.TYPE_STRING: "add_string",
            }
            method = mapping.get(field.type)
            if method is None:
                raise NotImplementedError(f"Unsupported field type for protozero writer: {field.type}")
            return method

        def reader_method(field: FieldDescriptor) -> str:
            mapping = {
                FieldDescriptor.TYPE_DOUBLE: "get_double",
                FieldDescriptor.TYPE_FLOAT: "get_float",
                FieldDescriptor.TYPE_INT64: "get_int64",
                FieldDescriptor.TYPE_UINT64: "get_uint64",
                FieldDescriptor.TYPE_INT32: "get_int32",
                FieldDescriptor.TYPE_FIXED64: "get_fixed64",
                FieldDescriptor.TYPE_FIXED32: "get_fixed32",
                FieldDescriptor.TYPE_BOOL: "get_bool",
                FieldDescriptor.TYPE_UINT32: "get_uint32",
                FieldDescriptor.TYPE_ENUM: "get_enum",
                FieldDescriptor.TYPE_SFIXED32: "get_sfixed32",
                FieldDescriptor.TYPE_SFIXED64: "get_sfixed64",
                FieldDescriptor.TYPE_SINT32: "get_sint32",
                FieldDescriptor.TYPE_SINT64: "get_sint64",
                FieldDescriptor.TYPE_BYTES: "get_bytes",
                FieldDescriptor.TYPE_STRING: "get_string",
            }
            method = mapping.get(field.type)
            if method is None:
                raise NotImplementedError(f"Unsupported field type for protozero reader: {field.type}")
            return method

        packed_methods = {
            FieldDescriptor.TYPE_DOUBLE: "get_packed_double",
            FieldDescriptor.TYPE_FLOAT: "get_packed_float",
            FieldDescriptor.TYPE_INT64: "get_packed_int64",
            FieldDescriptor.TYPE_UINT64: "get_packed_uint64",
            FieldDescriptor.TYPE_INT32: "get_packed_int32",
            FieldDescriptor.TYPE_FIXED64: "get_packed_fixed64",
            FieldDescriptor.TYPE_FIXED32: "get_packed_fixed32",
            FieldDescriptor.TYPE_BOOL: "get_packed_bool",
            FieldDescriptor.TYPE_UINT32: "get_packed_uint32",
            FieldDescriptor.TYPE_ENUM: "get_packed_enum",
            FieldDescriptor.TYPE_SFIXED32: "get_packed_sfixed32",
            FieldDescriptor.TYPE_SFIXED64: "get_packed_sfixed64",
            FieldDescriptor.TYPE_SINT32: "get_packed_sint32",
            FieldDescriptor.TYPE_SINT64: "get_packed_sint64",
        }
        packable_types = set(packed_methods.keys())

        writer.write(f"bool {flattened_name}::SerializeToProtozero(std::string* buffer) const {{")
        writer.indent()
        writer.write("if (!buffer) return false;")
        writer.write("buffer->clear();")
        writer.write("protozero::pbf_writer pbf(*buffer);")
        writer.write()

        for metadata in binding.field_metadata:
            field = metadata.field
            field_name = metadata.storage_name
            tag = field.number
            presence = metadata.presence_var
            category = metadata.category

            writer.write()
            if category in {"scalar", "bool", "enum"}:
                method = writer_method(field)
                value_expr = field_name if field.type != FieldDescriptor.TYPE_ENUM else f"static_cast<int32_t>({field_name})"
                if presence:
                    writer.write(f"if ({presence}) {{")
                    writer.indent()
                    writer.write(f"pbf.{method}({tag}, {value_expr});")
                    writer.dedent()
                    writer.write("}")
                else:
                    writer.write(f"pbf.{method}({tag}, {value_expr});")
            elif category == "string":
                if field.type == FieldDescriptor.TYPE_STRING:
                    method = "add_string"
                elif field.type == FieldDescriptor.TYPE_BYTES:
                    method = "add_bytes"
                else:
                    raise NotImplementedError("Unsupported string-like field type")
                if presence:
                    writer.write(f"if ({presence}) {{")
                    writer.indent()
                    writer.write(f"pbf.{method}({tag}, {field_name});")
                    writer.dedent()
                    writer.write("}")
                else:
                    writer.write(f"if (!{field_name}.empty()) {{")
                    writer.indent()
                    writer.write(f"pbf.{method}({tag}, {field_name});")
                    writer.dedent()
                    writer.write("}")
            elif category == "message":
                if presence:
                    writer.write(f"if ({presence}) {{")
                    writer.indent()
                    writer.write("std::string nested_buffer;")
                    writer.write(f"if (!{field_name}.SerializeToProtozero(&nested_buffer)) return false;")
                    writer.write(f"pbf.add_message({tag}, nested_buffer);")
                    writer.dedent()
                    writer.write("}")
                else:
                    writer.write("{")
                    writer.indent()
                    writer.write("std::string nested_buffer;")
                    writer.write(f"if (!{field_name}.SerializeToProtozero(&nested_buffer)) return false;")
                    writer.write("if (!nested_buffer.empty()) {")
                    writer.indent()
                    writer.write(f"pbf.add_message({tag}, nested_buffer);")
                    writer.dedent()
                    writer.write("}")
                    writer.dedent()
                    writer.write("}")
            elif category == "repeated":
                writer.write(f"for (const auto& elem : {field_name}) {{")
                writer.indent()
                if field.cpp_type == FieldDescriptor.CPPTYPE_MESSAGE:
                    writer.write("std::string nested_buffer;")
                    writer.write("if (!elem.SerializeToProtozero(&nested_buffer)) return false;")
                    writer.write(f"pbf.add_message({tag}, nested_buffer);")
                elif field.type == FieldDescriptor.TYPE_STRING:
                    writer.write(f"pbf.add_string({tag}, elem);")
                elif field.type == FieldDescriptor.TYPE_BYTES:
                    writer.write(f"pbf.add_bytes({tag}, elem);")
                else:
                    method = writer_method(field)
                    if field.type == FieldDescriptor.TYPE_ENUM:
                        writer.write(f"pbf.{method}({tag}, static_cast<int32_t>(elem));")
                    else:
                        writer.write(f"pbf.{method}({tag}, elem);")
                writer.dedent()
                writer.write("}")
            elif category == "map":
                key_field = field.message_type.fields_by_name["key"]
                value_field = field.message_type.fields_by_name["value"]
                writer.write(f"for (const auto& kv : {field_name}) {{")
                writer.indent()
                writer.write(f"protozero::pbf_writer entry(pbf, {tag});")
                writer.write("const auto& key = kv.first;")
                writer.write("const auto& value = kv.second;")
                if key_field.type == FieldDescriptor.TYPE_STRING:
                    writer.write("entry.add_string(1, key);")
                elif key_field.type == FieldDescriptor.TYPE_BYTES:
                    writer.write("entry.add_bytes(1, key);")
                elif key_field.type == FieldDescriptor.TYPE_ENUM:
                    writer.write("entry.add_enum(1, static_cast<int32_t>(key));")
                else:
                    key_method = writer_method(key_field)
                    writer.write(f"entry.{key_method}(1, key);")
                if metadata.value_category == "message":
                    writer.write("std::string value_buffer;")
                    writer.write("if (!value.SerializeToProtozero(&value_buffer)) return false;")
                    writer.write("entry.add_message(2, value_buffer);")
                elif metadata.value_category == "string":
                    if value_field.type == FieldDescriptor.TYPE_STRING:
                        writer.write("entry.add_string(2, value);")
                    elif value_field.type == FieldDescriptor.TYPE_BYTES:
                        writer.write("entry.add_bytes(2, value);")
                    else:
                        raise NotImplementedError("Map value marked as string but field type unsupported")
                elif metadata.value_category == "enum":
                    writer.write("entry.add_enum(2, static_cast<int32_t>(value));")
                else:
                    value_method = writer_method(value_field)
                    writer.write(f"entry.{value_method}(2, value);")
                writer.dedent()
                writer.write("}")
            else:
                raise NotImplementedError(f"Unsupported field category: {category}")

        writer.write()
        writer.write("return true;")
        writer.dedent()
        writer.write("}")
        writer.write()

        writer.write(f"bool {flattened_name}::SerializeToArray(void* data, int size) const {{")
        writer.indent()
        writer.write("if (size < 0) return false;")
        writer.write("std::string buffer;")
        writer.write("if (!SerializeToProtozero(&buffer)) return false;")
        writer.write("const size_t required = buffer.size();")
        writer.write("if (static_cast<size_t>(size) < required) return false;")
        writer.write("if (!data && required > 0) return false;")
        writer.write("if (required > 0 && data) {")
        writer.indent()
        writer.write("std::memcpy(data, buffer.data(), required);")
        writer.dedent()
        writer.write("}")
        writer.write("return true;")
        writer.dedent()
        writer.write("}")
        writer.write()

        writer.write(f"bool {flattened_name}::SerializeToString(std::string *output) const {{")
        writer.indent()
        writer.write("if (!output) return false;")
        writer.write("std::string buffer;")
        writer.write("if (!SerializeToProtozero(&buffer)) return false;")
        writer.write("output->assign(buffer.begin(), buffer.end());")
        writer.write("return true;")
        writer.dedent()
        writer.write("}")
        writer.write()

        writer.write(f"bool {flattened_name}::ParseFromArray(const void* data, int size) {{")
        writer.indent()
        writer.write("if (size < 0) return false;")
        writer.write("if (!data && size > 0) return false;")
        writer.write("try {")
        writer.indent()
        writer.write("Clear();")
        writer.write("protozero::pbf_reader reader(static_cast<const char*>(data), static_cast<size_t>(size));")
        writer.write("while (reader.next()) {")
        writer.indent()
        writer.write("switch (reader.tag()) {")
        writer.indent()

        for metadata in binding.field_metadata:
            field = metadata.field
            field_name = metadata.storage_name
            tag = field.number
            presence = metadata.presence_var
            category = metadata.category

            writer.write(f"case {tag}: {{")
            writer.indent()
            if category in {"scalar", "bool", "enum"}:
                method = reader_method(field)
                value_expr = f"reader.{method}()"
                if category == "enum":
                    writer.write(f"{field_name} = static_cast<{metadata.type_string}>({value_expr});")
                else:
                    writer.write(f"{field_name} = {value_expr};")
                if presence:
                    writer.write(f"{presence} = true;")
            elif category == "string":
                method = "get_string" if field.type == FieldDescriptor.TYPE_STRING else "get_bytes"
                writer.write(f"{field_name} = reader.{method}();")
                if presence:
                    writer.write(f"{presence} = true;")
            elif category == "message":
                writer.write("auto view = reader.get_view();")
                writer.write("if (view.size() > static_cast<size_t>(std::numeric_limits<int>::max())) return false;")
                writer.write(f"if (!{field_name}.ParseFromArray(view.data(), static_cast<int>(view.size()))) return false;")
                if presence:
                    writer.write(f"{presence} = true;")
            elif category == "repeated":
                if field.cpp_type == FieldDescriptor.CPPTYPE_MESSAGE:
                    writer.write("auto view = reader.get_view();")
                    writer.write("if (view.size() > static_cast<size_t>(std::numeric_limits<int>::max())) return false;")
                    writer.write(f"{field_name}.emplace_back();")
                    writer.write(f"auto& elem = {field_name}.back();")
                    writer.write("if (!elem.ParseFromArray(view.data(), static_cast<int>(view.size()))) return false;")
                elif field.type == FieldDescriptor.TYPE_STRING:
                    writer.write(f"{field_name}.emplace_back(reader.get_string());")
                elif field.type == FieldDescriptor.TYPE_BYTES:
                    writer.write(f"{field_name}.emplace_back(reader.get_bytes());")
                else:
                    method = reader_method(field)
                    element_type = metadata.element_type or "auto"
                    if field.type in packable_types:
                        packed_method = packed_methods[field.type]
                        writer.write("if (reader.has_wire_type(protozero::pbf_wire_type::length_delimited)) {")
                        writer.indent()
                        writer.write(f"auto range = reader.{packed_method}();")
                        writer.write("for (auto it = range.begin(); it != range.end(); ++it) {")
                        writer.indent()
                        if field.type == FieldDescriptor.TYPE_ENUM:
                            writer.write(f"{field_name}.push_back(static_cast<{element_type}>(*it));")
                        else:
                            writer.write(f"{field_name}.push_back(static_cast<{element_type}>(*it));")
                        writer.dedent()
                        writer.write("}")
                        writer.dedent()
                        writer.write("} else {")
                        writer.indent()
                        if field.type == FieldDescriptor.TYPE_ENUM:
                            writer.write(f"{field_name}.push_back(static_cast<{element_type}>(reader.{method}()));")
                        else:
                            writer.write(f"{field_name}.push_back(static_cast<{element_type}>(reader.{method}()));")
                        writer.dedent()
                        writer.write("}")
                    else:
                        if field.type == FieldDescriptor.TYPE_ENUM:
                            writer.write(f"{field_name}.push_back(static_cast<{element_type}>(reader.{method}()));")
                        else:
                            writer.write(f"{field_name}.push_back(static_cast<{element_type}>(reader.{method}()));")
            elif category == "map":
                key_field = field.message_type.fields_by_name["key"]
                value_field = field.message_type.fields_by_name["value"]
                writer.write("protozero::pbf_reader entry(reader.get_message());")
                writer.write(f"typename decltype({field_name})::key_type key{{}};")
                writer.write(f"typename decltype({field_name})::mapped_type value{{}};")
                writer.write("while (entry.next()) {")
                writer.indent()
                writer.write("switch (entry.tag()) {")
                writer.indent()
                writer.write("case 1: {")
                writer.indent()
                if key_field.type == FieldDescriptor.TYPE_STRING:
                    writer.write("key = entry.get_string();")
                elif key_field.type == FieldDescriptor.TYPE_BYTES:
                    writer.write("key = entry.get_bytes();")
                elif key_field.type == FieldDescriptor.TYPE_ENUM:
                    writer.write(f"key = static_cast<{metadata.key_type}>(entry.get_enum());")
                else:
                    key_reader = reader_method(key_field)
                    writer.write(f"key = entry.{key_reader}();")
                writer.write("break;")
                writer.dedent()
                writer.write("}")
                writer.write("case 2: {")
                writer.indent()
                if metadata.value_category == "message":
                    writer.write("auto view = entry.get_view();")
                    writer.write("if (view.size() > static_cast<size_t>(std::numeric_limits<int>::max())) return false;")
                    writer.write("if (!value.ParseFromArray(view.data(), static_cast<int>(view.size()))) return false;")
                elif metadata.value_category == "string":
                    if value_field.type == FieldDescriptor.TYPE_STRING:
                        writer.write("value = entry.get_string();")
                    else:
                        writer.write("value = entry.get_bytes();")
                elif metadata.value_category == "enum":
                    writer.write(f"value = static_cast<{metadata.value_type}>(entry.get_enum());")
                else:
                    value_reader = reader_method(value_field)
                    writer.write(f"value = entry.{value_reader}();")
                writer.write("break;")
                writer.dedent()
                writer.write("}")
                writer.write("default:")
                writer.indent()
                writer.write("entry.skip();")
                writer.write("break;")
                writer.dedent()
                writer.dedent()
                writer.write("}")
                writer.dedent()
                writer.write("}")
                writer.write(f"auto& dest = {field_name}[key];")
                writer.write("dest = std::move(value);")
            else:
                raise NotImplementedError(f"Unsupported field category: {category}")

            writer.write("break;")
            writer.dedent()
            writer.write("}")

        writer.write("default:")
        writer.indent()
        writer.write("reader.skip();")
        writer.write("break;")
        writer.dedent()
        writer.dedent()
        writer.write("}")
        writer.dedent()
        writer.write("}")
        writer.write("return true;")
        writer.dedent()
        writer.write("} catch (const protozero::exception&) {")
        writer.indent()
        writer.write("return false;")
        writer.dedent()
        writer.write("}")
        writer.dedent()
        writer.write("}")
        writer.write()

        writer.write(f"bool {flattened_name}::ParseFromString(const std::string& data) {{")
        writer.indent()
        writer.write("return ParseFromArray(data.data(), static_cast<int>(data.size()));")
        writer.dedent()
        writer.write("}")
        writer.write()


    @staticmethod
    def _is_presence_oneof(oneof: OneofDescriptor) -> bool:
        return oneof.name.startswith("has_") and len(oneof.fields) == 1

    def _make_field_metadata(self, field: FieldDescriptor, context: FileContext) -> FieldMetadata:
        storage_name = self._storage_name(field.name)
        if field.message_type and field.message_type.GetOptions().map_entry:
            key_field = field.message_type.fields_by_name["key"]
            value_field = field.message_type.fields_by_name["value"]
            key_type = self._base_field_type(key_field)
            value_type = self._base_field_type(value_field)
            type_string = f"std::map<{key_type}, {value_type}>"
            reg_name = self._map_registration_name(key_type, value_type)
            context.map_types.setdefault((key_type, value_type), reg_name)
            return FieldMetadata(
                field=field,
                type_string=type_string,
                initializer="",
                category="map",
                storage_name=storage_name,
                element_type=None,
                key_type=key_type,
                value_type=value_type,
                key_category=self._categorize_field(key_field),
                value_category=self._categorize_field(value_field),
                value_cpp_type=value_field.cpp_type,
            )
        if field.label == FieldDescriptor.LABEL_REPEATED:
            element_type = self._base_field_type(field)
            type_string = f"std::vector<{element_type}>"
            reg_name = self._vector_registration_name(element_type)
            context.vector_types.setdefault(element_type, reg_name)
            return FieldMetadata(
                field=field,
                type_string=type_string,
                initializer="",
                category="repeated",
                storage_name=storage_name,
                element_type=element_type,
                key_type=None,
                value_type=None,
                value_cpp_type=None,
            )
        base_type = self._base_field_type(field)
        init = self._default_initializer(field)
        category = self._categorize_field(field)
        return FieldMetadata(
            field=field,
            type_string=base_type,
            initializer=init,
            category=category,
            storage_name=storage_name,
            value_cpp_type=None,
        )

    def _base_field_type(self, field: FieldDescriptor) -> str:
        if field.cpp_type == FieldDescriptor.CPPTYPE_MESSAGE:
            return self._qualify_message(field.message_type)
        if field.cpp_type == FieldDescriptor.CPPTYPE_STRING:
            return "std::string"
        if field.cpp_type == FieldDescriptor.CPPTYPE_BOOL:
            return "bool"
        if field.cpp_type == FieldDescriptor.CPPTYPE_DOUBLE:
            return "double"
        if field.cpp_type == FieldDescriptor.CPPTYPE_FLOAT:
            return "float"
        if field.cpp_type == FieldDescriptor.CPPTYPE_INT32:
            return "int32_t"
        if field.cpp_type == FieldDescriptor.CPPTYPE_INT64:
            return "int64_t"
        if field.cpp_type == FieldDescriptor.CPPTYPE_UINT32:
            return "uint32_t"
        if field.cpp_type == FieldDescriptor.CPPTYPE_UINT64:
            return "uint64_t"
        if field.cpp_type == FieldDescriptor.CPPTYPE_ENUM:
            return self._qualify_enum(field.enum_type)
        raise NotImplementedError(f"Unsupported field type: {field.cpp_type}")

    def _default_initializer(self, field: FieldDescriptor) -> str:
        if field.label == FieldDescriptor.LABEL_REPEATED:
            return ""
        if field.message_type and not field.message_type.GetOptions().map_entry:
            if field.cpp_type == FieldDescriptor.CPPTYPE_MESSAGE:
                return " = {}"
        if field.cpp_type == FieldDescriptor.CPPTYPE_STRING:
            return " = {}"
        if field.cpp_type == FieldDescriptor.CPPTYPE_BOOL:
            return " = false"
        if field.cpp_type in (FieldDescriptor.CPPTYPE_DOUBLE, FieldDescriptor.CPPTYPE_FLOAT):
            return " = 0.0"
        if field.cpp_type in (
            FieldDescriptor.CPPTYPE_INT32,
            FieldDescriptor.CPPTYPE_INT64,
            FieldDescriptor.CPPTYPE_UINT32,
            FieldDescriptor.CPPTYPE_UINT64,
        ):
            return " = 0"
        if field.cpp_type == FieldDescriptor.CPPTYPE_ENUM:
            enum_type = field.enum_type
            default_value = enum_type.values[0]
            qualified = self._qualify_enum(enum_type)
            return f" = {qualified}::{default_value.name}"
        return ""

    @staticmethod
    def _categorize_field(field: FieldDescriptor) -> str:
        if field.cpp_type == FieldDescriptor.CPPTYPE_STRING:
            return "string"
        if field.cpp_type == FieldDescriptor.CPPTYPE_MESSAGE:
            return "message"
        if field.cpp_type == FieldDescriptor.CPPTYPE_BOOL:
            return "bool"
        if field.cpp_type == FieldDescriptor.CPPTYPE_ENUM:
            return "enum"
        return "scalar"

    def _emit_field_accessors(self, metadata: FieldMetadata, writer: CodeWriter) -> None:
        field = metadata.field
        name = field.name
        storage = metadata.storage_name
        presence = metadata.presence_var
        if metadata.category == "repeated":
            shim_type = f"valhalla::proto::RepeatedFieldShim<{metadata.element_type}>"
            #shim_member = f"{storage}__shim_"
            writer.write(f"inline const {metadata.type_string}& {name}() const {{ return {storage}; }}")
            writer.write(f"inline {metadata.type_string} get_{name}() const {{ return {storage}; }}")
            writer.write(f"inline void set_{name}(const {metadata.type_string}& value) {{ {storage} = value; }}")
            
            writer.write(
                f"{shim_type} mutable_{name}() {{return {storage}; }}"
            )
            writer.write(f"inline void clear_{name}() {{ {storage}.clear(); }}")
            writer.write(f"inline size_t {name}_size() const {{ return {storage}.size(); }}")
            if metadata.element_type:
                if field.cpp_type == FieldDescriptor.CPPTYPE_BOOL:
                    writer.write(f"inline bool {name}(int index) const {{ return {storage}[index]; }}")
                    writer.write(f"inline void set_{name}(int index, bool value) {{ {storage}[index] = value; }}")
                    writer.write(f"inline void add_{name}(bool value) {{ {storage}.push_back(value); }}")
                elif field.cpp_type == FieldDescriptor.CPPTYPE_MESSAGE:
                    writer.write(
                        f"inline const {metadata.element_type}& {name}(int index) const {{ return {storage}[index]; }}"
                    )
                    writer.write(
                        f"inline {metadata.element_type}* mutable_{name}(int index) {{ return &{storage}[index]; }}"
                    )
                    writer.write(
                        f"inline void set_{name}(int index, const {metadata.element_type}& value) {{ {storage}[index] = value; }}"
                    )
                    writer.write(
                        f"inline void set_{name}(int index, {metadata.element_type}&& value) {{ {storage}[index] = std::move(value); }}"
                    )
                    writer.write(
                        f"inline {metadata.element_type}* add_{name}() {{ {storage}.emplace_back(); return &{storage}.back(); }}"
                    )
                    writer.write(
                        f"inline void add_{name}(const {metadata.element_type}& value) {{ {storage}.push_back(value); }}"
                    )
                    writer.write(
                        f"inline void add_{name}({metadata.element_type}&& value) {{ {storage}.push_back(std::move(value)); }}"
                    )
                elif field.cpp_type == FieldDescriptor.CPPTYPE_STRING:
                    writer.write(
                        f"inline const std::string& {name}(int index) const {{ return {storage}[index]; }}"
                    )
                    writer.write(
                        f"inline void set_{name}(int index, const std::string& value) {{ {storage}[index] = value; }}"
                    )
                    writer.write(
                        f"inline void set_{name}(int index, std::string&& value) {{ {storage}[index] = std::move(value); }}"
                    )
                    writer.write(
                        f"inline std::string* mutable_{name}(int index) {{ return &{storage}[index]; }}"
                    )
                    writer.write(
                        f"inline std::string* add_{name}() {{ {storage}.emplace_back(); return &{storage}.back(); }}"
                    )
                    writer.write(
                        f"inline void add_{name}(std::string value) {{ {storage}.push_back(value); }}"
                    )
                else:
                    writer.write(f"inline {metadata.element_type} {name}(int index) const {{ return {storage}[index]; }}")
                    writer.write(
                        f"inline void set_{name}(int index, {metadata.element_type} value) {{ {storage}[index] = value; }}"
                    )
                    writer.write(
                        f"inline void add_{name}({metadata.element_type} value) {{ {storage}.push_back(value); }}"
                    )
            return
        if metadata.category == "map":
            shim_type = f"valhalla::proto::MapFieldShim<{metadata.key_type}, {metadata.value_type}>"
            #shim_member = f"{storage}__shim_"
            writer.write(f"inline const {metadata.type_string}& {name}() const {{ return {storage}; }}")
            writer.write(f"inline {metadata.type_string} get_{name}() const {{ return {storage}; }}")
            writer.write(
                f"inline {shim_type} mutable_{name}() {{ return {storage}; }}"
            )

            writer.write(f"inline void set_{name}(const {metadata.type_string}& value) {{ {storage} = value; }}")
            writer.write(f"inline void clear_{name}() {{ {storage}.clear(); }}")
            writer.write(f"inline size_t {name}_size() const {{ return {storage}.size(); }}")
            return
        if metadata.category == "string":
            writer.write(f"inline const std::string& {name}() const {{ return {storage}; }}")
            writer.write(f"inline std::string get_{name}() const {{ return {storage}; }}")
            set_clause = self._presence_set_clause(presence)
            clear_clause = self._presence_clear_clause(presence)
            writer.write(
                f"inline void set_{name}(const std::string& value) {{ {storage} = value;{set_clause} }}"
            )
            if presence:
                writer.write(
                    f"inline std::string* mutable_{name}() {{ {presence} = true; return &{storage}; }}"
                )
            else:
                writer.write(f"inline std::string* mutable_{name}() {{ return &{storage}; }}")
            writer.write(f"inline void clear_{name}() {{ {storage}.clear();{clear_clause} }}")
            if presence:
                writer.write(f"inline bool has_{name}() const {{ return {presence}; }}")
                writer.write(f"inline bool has_{name}_case() const {{ return {presence}; }}")
            return
        if metadata.category == "message":
            writer.write(f"inline const {metadata.type_string}& {name}() const {{ return {storage}; }}")
            writer.write(f"inline {metadata.type_string} get_{name}() const {{ return {storage}; }}")
            set_clause = self._presence_set_clause(presence)
            clear_clause = self._presence_clear_clause(presence)
            writer.write(
                f"inline {metadata.type_string}* mutable_{name}() {{ {set_clause} return &{storage}; }}"
            )

            writer.write(f"inline void set_{name}(const {metadata.type_string}& value) {{ {storage} = value; }}")

            writer.write(f"inline void clear_{name}() {{ {storage} = {metadata.type_string}{{}};{clear_clause} }}")
            if presence:
                writer.write(f"inline bool has_{name}() const {{ return {presence}; }}")
                writer.write(f"inline bool has_{name}_case() const {{ return {presence}; }}")
            return
        default_expr = self._default_reset_value(metadata)
        writer.write(f"inline {metadata.type_string} {name}() const {{ return {storage}; }}")
        writer.write(f"inline {metadata.type_string} get_{name}() const {{ return {storage}; }}")
        set_clause = self._presence_set_clause(presence)
        clear_clause = self._presence_clear_clause(presence)
        writer.write(f"inline void set_{name}({metadata.type_string} value) {{ {storage} = value;{set_clause} }}")
        writer.write(f"inline void clear_{name}() {{ {storage} = {default_expr};{clear_clause} }}")
        if presence:
            writer.write(f"inline bool has_{name}() const {{ return {presence}; }}")
            writer.write(f"inline bool has_{name}_case() const {{ return {presence}; }}")

    @staticmethod
    def _presence_set_clause(presence: Optional[str]) -> str:
        if not presence:
            return ""
        return f" {presence} = true;"

    @staticmethod
    def _presence_clear_clause(presence: Optional[str]) -> str:
        if not presence:
            return ""
        return f" {presence} = false;"

    @staticmethod
    def _default_reset_value(metadata: FieldMetadata) -> str:
        field = metadata.field
        if field.cpp_type == FieldDescriptor.CPPTYPE_BOOL:
            return "false"
        if field.cpp_type in (FieldDescriptor.CPPTYPE_FLOAT, FieldDescriptor.CPPTYPE_DOUBLE):
            return "0.0"
        if field.cpp_type in (
            FieldDescriptor.CPPTYPE_INT32,
            FieldDescriptor.CPPTYPE_INT64,
            FieldDescriptor.CPPTYPE_UINT32,
            FieldDescriptor.CPPTYPE_UINT64,
        ):
            return "0"
        if field.cpp_type == FieldDescriptor.CPPTYPE_ENUM:
            enum_type = field.enum_type
            qualified = Generator._qualify_enum(enum_type)
            return f"{qualified}::{enum_type.values[0].name}"
        return f"{metadata.type_string}{{}}"

    @staticmethod
    def _make_include_guard(filename: str) -> str:
        guard = re.sub(r"[^A-Za-z0-9]", "_", filename.upper())
        return f"VALHALLA_CUSTOM_{guard}_PB_H_"

    @staticmethod
    def _make_binding_block_name(filename: str) -> str:
        name = os.path.basename(filename)
        name = os.path.splitext(name)[0]
        sanitized = re.sub(r"[^A-Za-z0-9]", "_", name)
        return f"valhalla_proto_{sanitized}"

    @staticmethod
    def _binding_name(full_name: str) -> str:
        sanitized = full_name.replace('.', '_')
        sanitized = re.sub(r"[^A-Za-z0-9_]", "_", sanitized)
        return sanitized

    @staticmethod
    def _vector_registration_name(element_type: str) -> str:
        sanitized = re.sub(r"[^A-Za-z0-9]", "_", element_type)
        return f"vector_{sanitized}"

    @staticmethod
    def _map_registration_name(key_type: str, value_type: str) -> str:
        key = re.sub(r"[^A-Za-z0-9]", "_", key_type)
        value = re.sub(r"[^A-Za-z0-9]", "_", value_type)
        return f"map_{key}_to_{value}"

    @staticmethod
    def _storage_name(name: str) -> str:
        return name if name.endswith('_') else f"{name}_"

    @staticmethod
    def _get_flattened_message_name(descriptor: Descriptor) -> str:
        """Get the flattened name for a message (e.g., DirectionsLeg_Maneuver instead of Maneuver)."""
        parts = []
        current = descriptor
        while current is not None:
            parts.append(current.name)
            current = current.containing_type
        return "_".join(reversed(parts))

    @staticmethod
    def _qualify_message(descriptor: Descriptor) -> str:
        # Use flattened names for all messages (nested or not)
        flattened_name = Generator._get_flattened_message_name(descriptor)
        return f"{NAMESPACE}::{flattened_name}"

    @staticmethod
    def _qualify_enum(descriptor: EnumDescriptor) -> str:
        return f"{NAMESPACE}::{Generator._enum_type_name(descriptor)}"

    @staticmethod
    def _file_message_descriptors(file_descriptor: FileDescriptor) -> Iterable[Descriptor]:
        # Collect all messages including nested ones
        all_messages: List[Descriptor] = []
        
        def collect_messages(descriptor: Descriptor) -> None:
            all_messages.append(descriptor)
            for nested in descriptor.nested_types:
                if not nested.GetOptions().map_entry:
                    collect_messages(nested)
        
        for top_level in Generator._top_level_messages(file_descriptor):
            collect_messages(top_level)
        
        return Generator._topologically_sorted_messages(all_messages)

    @staticmethod
    def _topologically_sorted_messages(descriptors: Iterable[Descriptor]) -> List[Descriptor]:
        by_name = {descriptor.full_name: descriptor for descriptor in descriptors}
        dependencies_cache: Dict[str, List[str]] = {}
        for descriptor in descriptors:
            # Pass all messages by name, not just top-level
            dependencies_cache[descriptor.full_name] = Generator._collect_message_dependencies(descriptor, by_name)

        ordered: List[Descriptor] = []
        temp_mark: Dict[str, bool] = {}
        perm_mark: Dict[str, bool] = {}

        def visit(name: str) -> None:
            if perm_mark.get(name):
                return
            if temp_mark.get(name):
                raise RuntimeError(f"Cyclic message dependency detected involving {name}")
            temp_mark[name] = True
            for dep_name in dependencies_cache.get(name, []):
                visit(dep_name)
            temp_mark.pop(name, None)
            perm_mark[name] = True
            ordered.append(by_name[name])

        for descriptor in sorted(descriptors, key=lambda d: d.full_name):
            visit(descriptor.full_name)

        return ordered

    @staticmethod
    def _collect_message_dependencies(
        descriptor: Descriptor, all_messages_by_name: Dict[str, Descriptor]
    ) -> List[str]:
        dependencies: List[str] = []
        seen: set[str] = set()
        root_name = descriptor.full_name

        def visit(current: Descriptor) -> None:
            for field in current.fields:
                target = Generator._dependency_target(field)
                if target is None:
                    continue

                target_name = target.full_name
                if target_name == root_name:
                    continue
                if target_name not in all_messages_by_name:
                    continue
                if target_name in seen:
                    continue

                seen.add(target_name)
                dependencies.append(target_name)

            # No need to visit nested types anymore since they're all emitted at top level
            # for nested in current.nested_types:
            #     if nested.GetOptions().map_entry:
            #         continue
            #     visit(nested)

        visit(descriptor)
        dependencies.sort()
        return dependencies

    @staticmethod
    def _dependency_target(field: FieldDescriptor) -> Optional[Descriptor]:
        if not field.message_type:
            return None

        message_type = field.message_type
        if message_type.GetOptions().map_entry:
            value_field = message_type.fields_by_name.get("value")
            if value_field is None or value_field.cpp_type != FieldDescriptor.CPPTYPE_MESSAGE:
                return None
            message_type = value_field.message_type

        # Return the message itself (nested or top-level) since we're now emitting all at top level
        return message_type

    @staticmethod
    def _top_level_descriptor(descriptor: Descriptor) -> Optional[Descriptor]:
        current: Optional[Descriptor] = descriptor
        while current is not None and current.containing_type is not None:
            current = current.containing_type
        return current

    @staticmethod
    def _file_all_enum_descriptors(file_descriptor: FileDescriptor) -> Iterable[EnumDescriptor]:
        enums: List[EnumDescriptor] = []

        top_level_enums = getattr(file_descriptor, "enum_types_by_name", {})
        for name in sorted(top_level_enums):
            enums.append(top_level_enums[name])

        for message in Generator._top_level_messages(file_descriptor):
            Generator._collect_enums_from_message(message, enums)

        enums.sort(key=lambda enum: enum.full_name)
        return enums

    @staticmethod
    def _collect_enums_from_message(descriptor: Descriptor, sink: List[EnumDescriptor]) -> None:
        for enum_descriptor in descriptor.enum_types:
            sink.append(enum_descriptor)
        for nested in descriptor.nested_types:
            if nested.GetOptions().map_entry:
                continue
            Generator._collect_enums_from_message(nested, sink)

    @staticmethod
    def _top_level_messages(file_descriptor: FileDescriptor) -> List[Descriptor]:
        messages = getattr(file_descriptor, "message_types_by_name", {})
        return [messages[name] for name in sorted(messages)]

    @staticmethod
    def _enum_type_name(enum_descriptor: EnumDescriptor) -> str:
        parts = [enum_descriptor.name]
        container = enum_descriptor.containing_type
        while container is not None:
            parts.append(container.name)
            container = container.containing_type
        return "_".join(reversed(parts))

    @staticmethod
    def _scoped_parts_from_descriptor(descriptor: Any) -> List[str]:
        parts = descriptor.full_name.split('.')
        package = descriptor.file.package if descriptor.file and descriptor.file.package else ""
        if package:
            package_parts = package.split('.')
            if parts[: len(package_parts)] == package_parts:
                return parts[len(package_parts) :]
        return parts


def main() -> None:
    data = sys.stdin.buffer.read()
    request_cls = getattr(plugin_pb2, "CodeGeneratorRequest")
    request = request_cls()
    request.ParseFromString(data)
    generator = Generator(request)
    response = generator.generate()
    sys.stdout.buffer.write(response.SerializeToString())


if __name__ == "__main__":
    main()
